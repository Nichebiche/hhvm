// @generated by Thrift for thrift/compiler/test/fixtures/sink/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift service definitions for `module`.


/// Service definitions for `SinkService`.
pub mod sink_service {
    pub struct MethodSinkResult {
        pub stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
            ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodSinkExn>>
        ) -> ::futures::future::BoxFuture<'static,
            ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodSinkFinalExn>
        > + Send>,
        pub buffer_size: u64,
        pub chunk_timeout: ::std::time::Duration,
    }

    impl MethodSinkResult {
        pub fn new(
            stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodSinkFinalExn>
            > + Send>,
        ) -> Self {
            Self {
                stream_handler,
                buffer_size: 100,
                chunk_timeout: ::std::time::Duration::ZERO,
            }
        }

        pub fn with_buffer_size(mut self, buffer_size: u64) -> Self {
            self.buffer_size = buffer_size;
            self
        }

        pub fn with_chunk_timeout(mut self, chunk_timeout: ::std::time::Duration) -> Self {
            self.chunk_timeout = chunk_timeout;
            self
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodSinkExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodSinkExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodSinkExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodSinkExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodSinkExn {
        type Success = crate::types::SinkPayload;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[doc(hidden)]
    pub enum MethodSinkReader {}
    impl ::fbthrift::help::DeserializeExn for MethodSinkReader {
        type Success = crate::types::SinkPayload;
        type Error = MethodSinkExn;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "MethodSinkError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "MethodSinkError"),
                )
                .into(),
            )
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodSinkFinalExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodSinkFinalExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodSinkFinalExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodSinkFinalExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodSinkFinalExn {
        type Success = crate::types::FinalResponse;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::std::convert::From<MethodExn> for ::fbthrift::NonthrowingFunctionError {
        fn from(err: MethodExn) -> Self {
            match err {
                MethodExn::ApplicationException(aexn) => ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for MethodExn {
        fn from(err: ::fbthrift::NonthrowingFunctionError) -> Self {
            match err {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => MethodExn::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => MethodExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::ExceptionInfo for MethodExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodExn {
        type Success = ();

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(_success) => {
                    p.write_field_begin("Success", ::fbthrift::TType::Void, 0i16);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_aexn)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    pub struct MethodAndReponseSinkResult {
        pub initial_response: crate::types::InitialResponse,
        pub stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
            ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodAndReponseSinkExn>>
        ) -> ::futures::future::BoxFuture<'static,
            ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodAndReponseSinkFinalExn>
        > + Send>,
        pub buffer_size: u64,
        pub chunk_timeout: ::std::time::Duration,
    }

    impl MethodAndReponseSinkResult {
        pub fn new(
            initial_response: crate::types::InitialResponse,
            stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodAndReponseSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodAndReponseSinkFinalExn>
            > + Send>,
        ) -> Self {
            Self {
                initial_response,
                stream_handler,
                buffer_size: 100,
                chunk_timeout: ::std::time::Duration::ZERO,
            }
        }

        pub fn with_buffer_size(mut self, buffer_size: u64) -> Self {
            self.buffer_size = buffer_size;
            self
        }

        pub fn with_chunk_timeout(mut self, chunk_timeout: ::std::time::Duration) -> Self {
            self.chunk_timeout = chunk_timeout;
            self
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodAndReponseSinkExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodAndReponseSinkExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodAndReponseSinkExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodAndReponseSinkExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodAndReponseSinkExn {
        type Success = crate::types::SinkPayload;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[doc(hidden)]
    pub enum MethodAndReponseSinkReader {}
    impl ::fbthrift::help::DeserializeExn for MethodAndReponseSinkReader {
        type Success = crate::types::SinkPayload;
        type Error = MethodAndReponseSinkExn;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "MethodAndReponseSinkError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "MethodAndReponseSinkError"),
                )
                .into(),
            )
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodAndReponseSinkFinalExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodAndReponseSinkFinalExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodAndReponseSinkFinalExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodAndReponseSinkFinalExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodAndReponseSinkFinalExn {
        type Success = crate::types::FinalResponse;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodAndReponseExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::std::convert::From<MethodAndReponseExn> for ::fbthrift::NonthrowingFunctionError {
        fn from(err: MethodAndReponseExn) -> Self {
            match err {
                MethodAndReponseExn::ApplicationException(aexn) => ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for MethodAndReponseExn {
        fn from(err: ::fbthrift::NonthrowingFunctionError) -> Self {
            match err {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => MethodAndReponseExn::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => MethodAndReponseExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodAndReponseExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::ExceptionInfo for MethodAndReponseExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodAndReponseExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodAndReponseExn {
        type Success = crate::types::InitialResponse;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(_success) => {
                    p.write_field_begin("Success", ::fbthrift::TType::Struct, 0i16);
                    ::fbthrift::Serialize::rs_thrift_write(_success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_aexn)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    pub struct MethodThrowSinkResult {
        pub stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
            ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodThrowSinkExn>>
        ) -> ::futures::future::BoxFuture<'static,
            ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodThrowSinkFinalExn>
        > + Send>,
        pub buffer_size: u64,
        pub chunk_timeout: ::std::time::Duration,
    }

    impl MethodThrowSinkResult {
        pub fn new(
            stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodThrowSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodThrowSinkFinalExn>
            > + Send>,
        ) -> Self {
            Self {
                stream_handler,
                buffer_size: 100,
                chunk_timeout: ::std::time::Duration::ZERO,
            }
        }

        pub fn with_buffer_size(mut self, buffer_size: u64) -> Self {
            self.buffer_size = buffer_size;
            self
        }

        pub fn with_chunk_timeout(mut self, chunk_timeout: ::std::time::Duration) -> Self {
            self.chunk_timeout = chunk_timeout;
            self
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodThrowSinkExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodThrowSinkExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodThrowSinkExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodThrowSinkExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodThrowSinkExn {
        type Success = crate::types::SinkPayload;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[doc(hidden)]
    pub enum MethodThrowSinkReader {}
    impl ::fbthrift::help::DeserializeExn for MethodThrowSinkReader {
        type Success = crate::types::SinkPayload;
        type Error = MethodThrowSinkExn;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "MethodThrowSinkError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "MethodThrowSinkError"),
                )
                .into(),
            )
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodThrowSinkFinalExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodThrowSinkFinalExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodThrowSinkFinalExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodThrowSinkFinalExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodThrowSinkFinalExn {
        type Success = crate::types::FinalResponse;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodThrowExn {
        ex(crate::types::InitialException),
        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::std::convert::From<crate::types::InitialException> for MethodThrowExn {
        fn from(exn: crate::types::InitialException) -> Self {
            Self::ex(exn)
        }
    }


    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodThrowExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::ExceptionInfo for MethodThrowExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
                Self::ex(exn) => exn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
                Self::ex(exn) => exn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                Self::ex(exn) => exn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodThrowExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                Self::ex(_exn) => fbthrift::ResultType::Error,
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodThrowExn {
        type Success = ();

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(_success) => {
                    p.write_field_begin("Success", ::fbthrift::TType::Void, 0i16);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ex(inner)) => {
                    p.write_field_begin(
                        "ex",
                        ::fbthrift::TType::Struct,
                        1,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(inner, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ApplicationException(_aexn)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    pub struct MethodSinkThrowSinkResult {
        pub stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
            ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodSinkThrowSinkExn>>
        ) -> ::futures::future::BoxFuture<'static,
            ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodSinkThrowSinkFinalExn>
        > + Send>,
        pub buffer_size: u64,
        pub chunk_timeout: ::std::time::Duration,
    }

    impl MethodSinkThrowSinkResult {
        pub fn new(
            stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodSinkThrowSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodSinkThrowSinkFinalExn>
            > + Send>,
        ) -> Self {
            Self {
                stream_handler,
                buffer_size: 100,
                chunk_timeout: ::std::time::Duration::ZERO,
            }
        }

        pub fn with_buffer_size(mut self, buffer_size: u64) -> Self {
            self.buffer_size = buffer_size;
            self
        }

        pub fn with_chunk_timeout(mut self, chunk_timeout: ::std::time::Duration) -> Self {
            self.chunk_timeout = chunk_timeout;
            self
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodSinkThrowSinkExn {
        ex(crate::types::SinkException1),
        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodSinkThrowSinkExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
                Self::ex(exn) => exn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
                Self::ex(exn) => exn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                Self::ex(exn) => exn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodSinkThrowSinkExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                Self::ex(_exn) => fbthrift::ResultType::Error,
            }
        }
    }

    impl ::std::convert::From<crate::types::SinkException1> for MethodSinkThrowSinkExn {
        fn from(exn: crate::types::SinkException1) -> Self {
            Self::ex(exn)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodSinkThrowSinkExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodSinkThrowSinkExn {
        type Success = crate::types::SinkPayload;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ex(inner)) => {
                    p.write_field_begin(
                        "ex",
                        ::fbthrift::TType::Struct,
                        1,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(inner, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[doc(hidden)]
    pub enum MethodSinkThrowSinkReader {}
    impl ::fbthrift::help::DeserializeExn for MethodSinkThrowSinkReader {
        type Success = crate::types::SinkPayload;
        type Error = MethodSinkThrowSinkExn;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::ex(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "MethodSinkThrowSinkError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "MethodSinkThrowSinkError"),
                )
                .into(),
            )
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodSinkThrowSinkFinalExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodSinkThrowSinkFinalExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodSinkThrowSinkFinalExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodSinkThrowSinkFinalExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodSinkThrowSinkFinalExn {
        type Success = crate::types::FinalResponse;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodSinkThrowExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::std::convert::From<MethodSinkThrowExn> for ::fbthrift::NonthrowingFunctionError {
        fn from(err: MethodSinkThrowExn) -> Self {
            match err {
                MethodSinkThrowExn::ApplicationException(aexn) => ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for MethodSinkThrowExn {
        fn from(err: ::fbthrift::NonthrowingFunctionError) -> Self {
            match err {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => MethodSinkThrowExn::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => MethodSinkThrowExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodSinkThrowExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::ExceptionInfo for MethodSinkThrowExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodSinkThrowExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodSinkThrowExn {
        type Success = ();

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(_success) => {
                    p.write_field_begin("Success", ::fbthrift::TType::Void, 0i16);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_aexn)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    pub struct MethodFinalThrowSinkResult {
        pub stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
            ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodFinalThrowSinkExn>>
        ) -> ::futures::future::BoxFuture<'static,
            ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodFinalThrowSinkFinalExn>
        > + Send>,
        pub buffer_size: u64,
        pub chunk_timeout: ::std::time::Duration,
    }

    impl MethodFinalThrowSinkResult {
        pub fn new(
            stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodFinalThrowSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodFinalThrowSinkFinalExn>
            > + Send>,
        ) -> Self {
            Self {
                stream_handler,
                buffer_size: 100,
                chunk_timeout: ::std::time::Duration::ZERO,
            }
        }

        pub fn with_buffer_size(mut self, buffer_size: u64) -> Self {
            self.buffer_size = buffer_size;
            self
        }

        pub fn with_chunk_timeout(mut self, chunk_timeout: ::std::time::Duration) -> Self {
            self.chunk_timeout = chunk_timeout;
            self
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodFinalThrowSinkExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodFinalThrowSinkExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodFinalThrowSinkExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodFinalThrowSinkExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodFinalThrowSinkExn {
        type Success = crate::types::SinkPayload;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[doc(hidden)]
    pub enum MethodFinalThrowSinkReader {}
    impl ::fbthrift::help::DeserializeExn for MethodFinalThrowSinkReader {
        type Success = crate::types::SinkPayload;
        type Error = MethodFinalThrowSinkExn;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "MethodFinalThrowSinkError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "MethodFinalThrowSinkError"),
                )
                .into(),
            )
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodFinalThrowSinkFinalExn {
        ex(crate::types::SinkException2),
        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodFinalThrowSinkFinalExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
                Self::ex(exn) => exn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
                Self::ex(exn) => exn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                Self::ex(exn) => exn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodFinalThrowSinkFinalExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                Self::ex(_exn) => fbthrift::ResultType::Error,
            }
        }
    }

    impl ::std::convert::From<crate::types::SinkException2> for MethodFinalThrowSinkFinalExn {
        fn from(exn: crate::types::SinkException2) -> Self {
            Self::ex(exn)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodFinalThrowSinkFinalExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodFinalThrowSinkFinalExn {
        type Success = crate::types::FinalResponse;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ex(inner)) => {
                    p.write_field_begin(
                        "ex",
                        ::fbthrift::TType::Struct,
                        1,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(inner, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodFinalThrowExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::std::convert::From<MethodFinalThrowExn> for ::fbthrift::NonthrowingFunctionError {
        fn from(err: MethodFinalThrowExn) -> Self {
            match err {
                MethodFinalThrowExn::ApplicationException(aexn) => ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for MethodFinalThrowExn {
        fn from(err: ::fbthrift::NonthrowingFunctionError) -> Self {
            match err {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => MethodFinalThrowExn::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => MethodFinalThrowExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodFinalThrowExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::ExceptionInfo for MethodFinalThrowExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodFinalThrowExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodFinalThrowExn {
        type Success = ();

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(_success) => {
                    p.write_field_begin("Success", ::fbthrift::TType::Void, 0i16);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_aexn)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    pub struct MethodBothThrowSinkResult {
        pub stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
            ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodBothThrowSinkExn>>
        ) -> ::futures::future::BoxFuture<'static,
            ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodBothThrowSinkFinalExn>
        > + Send>,
        pub buffer_size: u64,
        pub chunk_timeout: ::std::time::Duration,
    }

    impl MethodBothThrowSinkResult {
        pub fn new(
            stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodBothThrowSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodBothThrowSinkFinalExn>
            > + Send>,
        ) -> Self {
            Self {
                stream_handler,
                buffer_size: 100,
                chunk_timeout: ::std::time::Duration::ZERO,
            }
        }

        pub fn with_buffer_size(mut self, buffer_size: u64) -> Self {
            self.buffer_size = buffer_size;
            self
        }

        pub fn with_chunk_timeout(mut self, chunk_timeout: ::std::time::Duration) -> Self {
            self.chunk_timeout = chunk_timeout;
            self
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodBothThrowSinkExn {
        ex(crate::types::SinkException1),
        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodBothThrowSinkExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
                Self::ex(exn) => exn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
                Self::ex(exn) => exn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                Self::ex(exn) => exn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodBothThrowSinkExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                Self::ex(_exn) => fbthrift::ResultType::Error,
            }
        }
    }

    impl ::std::convert::From<crate::types::SinkException1> for MethodBothThrowSinkExn {
        fn from(exn: crate::types::SinkException1) -> Self {
            Self::ex(exn)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodBothThrowSinkExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodBothThrowSinkExn {
        type Success = crate::types::SinkPayload;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ex(inner)) => {
                    p.write_field_begin(
                        "ex",
                        ::fbthrift::TType::Struct,
                        1,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(inner, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[doc(hidden)]
    pub enum MethodBothThrowSinkReader {}
    impl ::fbthrift::help::DeserializeExn for MethodBothThrowSinkReader {
        type Success = crate::types::SinkPayload;
        type Error = MethodBothThrowSinkExn;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::ex(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "MethodBothThrowSinkError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "MethodBothThrowSinkError"),
                )
                .into(),
            )
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodBothThrowSinkFinalExn {
        ex(crate::types::SinkException2),
        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodBothThrowSinkFinalExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
                Self::ex(exn) => exn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
                Self::ex(exn) => exn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                Self::ex(exn) => exn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodBothThrowSinkFinalExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                Self::ex(_exn) => fbthrift::ResultType::Error,
            }
        }
    }

    impl ::std::convert::From<crate::types::SinkException2> for MethodBothThrowSinkFinalExn {
        fn from(exn: crate::types::SinkException2) -> Self {
            Self::ex(exn)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodBothThrowSinkFinalExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodBothThrowSinkFinalExn {
        type Success = crate::types::FinalResponse;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ex(inner)) => {
                    p.write_field_begin(
                        "ex",
                        ::fbthrift::TType::Struct,
                        1,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(inner, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodBothThrowExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::std::convert::From<MethodBothThrowExn> for ::fbthrift::NonthrowingFunctionError {
        fn from(err: MethodBothThrowExn) -> Self {
            match err {
                MethodBothThrowExn::ApplicationException(aexn) => ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for MethodBothThrowExn {
        fn from(err: ::fbthrift::NonthrowingFunctionError) -> Self {
            match err {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => MethodBothThrowExn::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => MethodBothThrowExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodBothThrowExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::ExceptionInfo for MethodBothThrowExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodBothThrowExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodBothThrowExn {
        type Success = ();

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(_success) => {
                    p.write_field_begin("Success", ::fbthrift::TType::Void, 0i16);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_aexn)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    pub struct MethodFastSinkResult {
        pub stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
            ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodFastSinkExn>>
        ) -> ::futures::future::BoxFuture<'static,
            ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodFastSinkFinalExn>
        > + Send>,
        pub buffer_size: u64,
        pub chunk_timeout: ::std::time::Duration,
    }

    impl MethodFastSinkResult {
        pub fn new(
            stream_handler: ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodFastSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodFastSinkFinalExn>
            > + Send>,
        ) -> Self {
            Self {
                stream_handler,
                buffer_size: 100,
                chunk_timeout: ::std::time::Duration::ZERO,
            }
        }

        pub fn with_buffer_size(mut self, buffer_size: u64) -> Self {
            self.buffer_size = buffer_size;
            self
        }

        pub fn with_chunk_timeout(mut self, chunk_timeout: ::std::time::Duration) -> Self {
            self.chunk_timeout = chunk_timeout;
            self
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodFastSinkExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodFastSinkExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodFastSinkExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodFastSinkExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodFastSinkExn {
        type Success = crate::types::SinkPayload;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[doc(hidden)]
    pub enum MethodFastSinkReader {}
    impl ::fbthrift::help::DeserializeExn for MethodFastSinkReader {
        type Success = crate::types::SinkPayload;
        type Error = MethodFastSinkExn;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "MethodFastSinkError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "MethodFastSinkError"),
                )
                .into(),
            )
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodFastSinkFinalExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::fbthrift::ExceptionInfo for MethodFastSinkFinalExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodFastSinkFinalExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodFastSinkFinalExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodFastSinkFinalExn {
        type Success = crate::types::FinalResponse;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::Struct,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    #[derive(Clone, Debug)]
    pub enum MethodFastExn {

        ApplicationException(::fbthrift::ApplicationException),
    }

    impl ::std::convert::From<MethodFastExn> for ::fbthrift::NonthrowingFunctionError {
        fn from(err: MethodFastExn) -> Self {
            match err {
                MethodFastExn::ApplicationException(aexn) => ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for MethodFastExn {
        fn from(err: ::fbthrift::NonthrowingFunctionError) -> Self {
            match err {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => MethodFastExn::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => MethodFastExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for MethodFastExn {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::fbthrift::ExceptionInfo for MethodFastExn {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for MethodFastExn {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for MethodFastExn {
        type Success = ();

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(_success) => {
                    p.write_field_begin("Success", ::fbthrift::TType::Void, 0i16);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_aexn)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }
}
