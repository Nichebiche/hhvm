// @generated by Thrift for thrift/compiler/test/fixtures/sink/src/module.thrift
// This file is probably not the place you want to edit!

//! Server definitions for `module`.

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, unused_imports, clippy::all)]


#[doc(inline)]
pub use :: as types;

pub mod errors {
    #[doc(inline)]
    pub use ::::services::sink_service;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::sink_service::*;
}

pub(crate) use crate as server;
pub(crate) use ::::services;



#[::async_trait::async_trait]
pub trait SinkService: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn method(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodSinkResult, crate::services::sink_service::MethodExn> {
        ::std::result::Result::Err(crate::services::sink_service::MethodExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "SinkService",
                "method",
            ),
        ))
    }
    async fn methodAndReponse(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodAndReponseSinkResult, crate::services::sink_service::MethodAndReponseExn> {
        ::std::result::Result::Err(crate::services::sink_service::MethodAndReponseExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "SinkService",
                "methodAndReponse",
            ),
        ))
    }
    async fn methodThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodThrowSinkResult, crate::services::sink_service::MethodThrowExn> {
        ::std::result::Result::Err(crate::services::sink_service::MethodThrowExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "SinkService",
                "methodThrow",
            ),
        ))
    }
    async fn methodSinkThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodSinkThrowSinkResult, crate::services::sink_service::MethodSinkThrowExn> {
        ::std::result::Result::Err(crate::services::sink_service::MethodSinkThrowExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "SinkService",
                "methodSinkThrow",
            ),
        ))
    }
    async fn methodFinalThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodFinalThrowSinkResult, crate::services::sink_service::MethodFinalThrowExn> {
        ::std::result::Result::Err(crate::services::sink_service::MethodFinalThrowExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "SinkService",
                "methodFinalThrow",
            ),
        ))
    }
    async fn methodBothThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodBothThrowSinkResult, crate::services::sink_service::MethodBothThrowExn> {
        ::std::result::Result::Err(crate::services::sink_service::MethodBothThrowExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "SinkService",
                "methodBothThrow",
            ),
        ))
    }
    async fn methodFast(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodFastSinkResult, crate::services::sink_service::MethodFastExn> {
        ::std::result::Result::Err(crate::services::sink_service::MethodFastExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "SinkService",
                "methodFast",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> SinkService for ::std::boxed::Box<T>
where
    T: SinkService + Send + Sync + ?Sized,
{
    async fn method(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodSinkResult, crate::services::sink_service::MethodExn> {
        (**self).method(
        ).await
    }
    async fn methodAndReponse(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodAndReponseSinkResult, crate::services::sink_service::MethodAndReponseExn> {
        (**self).methodAndReponse(
        ).await
    }
    async fn methodThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodThrowSinkResult, crate::services::sink_service::MethodThrowExn> {
        (**self).methodThrow(
        ).await
    }
    async fn methodSinkThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodSinkThrowSinkResult, crate::services::sink_service::MethodSinkThrowExn> {
        (**self).methodSinkThrow(
        ).await
    }
    async fn methodFinalThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodFinalThrowSinkResult, crate::services::sink_service::MethodFinalThrowExn> {
        (**self).methodFinalThrow(
        ).await
    }
    async fn methodBothThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodBothThrowSinkResult, crate::services::sink_service::MethodBothThrowExn> {
        (**self).methodBothThrow(
        ).await
    }
    async fn methodFast(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodFastSinkResult, crate::services::sink_service::MethodFastExn> {
        (**self).methodFast(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> SinkService for ::std::sync::Arc<T>
where
    T: SinkService + Send + Sync + ?Sized,
{
    async fn method(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodSinkResult, crate::services::sink_service::MethodExn> {
        (**self).method(
        ).await
    }
    async fn methodAndReponse(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodAndReponseSinkResult, crate::services::sink_service::MethodAndReponseExn> {
        (**self).methodAndReponse(
        ).await
    }
    async fn methodThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodThrowSinkResult, crate::services::sink_service::MethodThrowExn> {
        (**self).methodThrow(
        ).await
    }
    async fn methodSinkThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodSinkThrowSinkResult, crate::services::sink_service::MethodSinkThrowExn> {
        (**self).methodSinkThrow(
        ).await
    }
    async fn methodFinalThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodFinalThrowSinkResult, crate::services::sink_service::MethodFinalThrowExn> {
        (**self).methodFinalThrow(
        ).await
    }
    async fn methodBothThrow(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodBothThrowSinkResult, crate::services::sink_service::MethodBothThrowExn> {
        (**self).methodBothThrow(
        ).await
    }
    async fn methodFast(
        &self,
    ) -> ::std::result::Result<crate::services::sink_service::MethodFastSinkResult, crate::services::sink_service::MethodFastExn> {
        (**self).methodFast(
        ).await
    }
}
/// Processor for SinkService's methods.
#[derive(Clone, Debug)]
pub struct SinkServiceProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}


struct Args_SinkService_method {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_SinkService_method {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "SinkService.method"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_SinkService_methodAndReponse {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_SinkService_methodAndReponse {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "SinkService.methodAndReponse"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_SinkService_methodThrow {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_SinkService_methodThrow {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "SinkService.methodThrow"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_SinkService_methodSinkThrow {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_SinkService_methodSinkThrow {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "SinkService.methodSinkThrow"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_SinkService_methodFinalThrow {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_SinkService_methodFinalThrow {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "SinkService.methodFinalThrow"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_SinkService_methodBothThrow {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_SinkService_methodBothThrow {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "SinkService.methodBothThrow"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_SinkService_methodFast {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_SinkService_methodFast {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "SinkService.methodFast"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

impl<P, H, R, RS> SinkServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: SinkService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "SinkService.method"))]
    async fn handle_method<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"SinkService";
        const METHOD_NAME: &::std::ffi::CStr = c"method";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"SinkService.method";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_SinkService_method = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.method(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "SinkService.method", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "SinkService.method", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.method", exn);
                ::tracing::error!(method = "SinkService.method", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::sink_service::MethodExn::ApplicationException(aexn))
            }
        };

        // Process the Thrift SINK encoded request

        use ::futures::StreamExt as _;

        let (first_result, stream_fn, buffer_size, chunk_timeout): (
            ::std::result::Result::<(), crate::services::sink_service::MethodExn>,
            ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodSinkFinalExn>
            > + Send>,
            _,
            _,
        ) = match res {
            Ok(crate::errors::sink_service::MethodSinkResult {
                stream_handler,
                buffer_size,
                chunk_timeout,
            }) => (::std::result::Result::Ok(()), stream_handler, buffer_size, chunk_timeout),
            Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.method", Box::new("Stream function builder failed to execute"));
                ::std::result::Result::Err(crate::services::sink_service::MethodSinkFinalExn::ApplicationException(aexn))
            }.boxed()), 100, ::std::time::Duration::ZERO),
        };

        let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::sink_service::MethodExn>(
            "method",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            first_result,
        )?;
        let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
        let stream =
            ::std::panic::AssertUnwindSafe(input_stream)
                .catch_unwind()
                .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                    match item {
                        ::std::result::Result::Err(exn) => {
                            tracing::error!(?exn, method="SinkService.method", "Sink stream unwind");
                            let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.method", exn);
                            ::std::result::Result::Err(crate::errors::sink_service::MethodSinkExn::ApplicationException(aexn))
                        },
                        ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                            let mut de = P::deserializer(item_enc);
                            let res = <crate::errors::sink_service::MethodSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                            match res {
                                Ok(r) => r,
                                Err(exn) => {
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.method", Box::new(exn));
                                    ::std::result::Result::Err(crate::errors::sink_service::MethodSinkExn::ApplicationException(aexn))
                                }
                            }
                        },
                        ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                            ::std::result::Result::Err(crate::errors::sink_service::MethodSinkExn::ApplicationException(aexn))
                        }
                    }
                )
                .boxed();
        let final_result = stream_fn(stream).await;
        let enc_final_result = match final_result {
            ::std::result::Result::Ok(ok_result) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodSinkFinalExn>(
                    ::std::result::Result::Ok(ok_result),
                    "method",
                );
                ::fbthrift::SerializedStreamElement::Success(payload)
            }
            ::std::result::Result::Err(crate::services::sink_service::MethodSinkFinalExn::ApplicationException(aexn)) => {
                tracing::info!(?aexn, method="SinkService.method", "Sink Final ApplicationException");
                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
            }
            
        };
        final_result_callback(enc_final_result);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "SinkService.methodAndReponse"))]
    async fn handle_methodAndReponse<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"SinkService";
        const METHOD_NAME: &::std::ffi::CStr = c"methodAndReponse";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"SinkService.methodAndReponse";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_SinkService_methodAndReponse = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.methodAndReponse(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "SinkService.methodAndReponse", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "SinkService.methodAndReponse", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodAndReponse", exn);
                ::tracing::error!(method = "SinkService.methodAndReponse", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::sink_service::MethodAndReponseExn::ApplicationException(aexn))
            }
        };

        // Process the Thrift SINK encoded request

        use ::futures::StreamExt as _;

        let (first_result, stream_fn, buffer_size, chunk_timeout): (
            ::std::result::Result::<crate::types::InitialResponse, crate::services::sink_service::MethodAndReponseExn>,
            ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodAndReponseSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodAndReponseSinkFinalExn>
            > + Send>,
            _,
            _,
        ) = match res {
            Ok(crate::errors::sink_service::MethodAndReponseSinkResult {
                initial_response,
                stream_handler,
                buffer_size,
                chunk_timeout,
            }) => (::std::result::Result::Ok(initial_response), stream_handler, buffer_size, chunk_timeout),
            Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodAndReponse", Box::new("Stream function builder failed to execute"));
                ::std::result::Result::Err(crate::services::sink_service::MethodAndReponseSinkFinalExn::ApplicationException(aexn))
            }.boxed()), 100, ::std::time::Duration::ZERO),
        };

        let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::sink_service::MethodAndReponseExn>(
            "methodAndReponse",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            first_result,
        )?;
        let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
        let stream =
            ::std::panic::AssertUnwindSafe(input_stream)
                .catch_unwind()
                .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                    match item {
                        ::std::result::Result::Err(exn) => {
                            tracing::error!(?exn, method="SinkService.methodAndReponse", "Sink stream unwind");
                            let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodAndReponse", exn);
                            ::std::result::Result::Err(crate::errors::sink_service::MethodAndReponseSinkExn::ApplicationException(aexn))
                        },
                        ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                            let mut de = P::deserializer(item_enc);
                            let res = <crate::errors::sink_service::MethodAndReponseSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                            match res {
                                Ok(r) => r,
                                Err(exn) => {
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodAndReponse", Box::new(exn));
                                    ::std::result::Result::Err(crate::errors::sink_service::MethodAndReponseSinkExn::ApplicationException(aexn))
                                }
                            }
                        },
                        ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                            ::std::result::Result::Err(crate::errors::sink_service::MethodAndReponseSinkExn::ApplicationException(aexn))
                        }
                    }
                )
                .boxed();
        let final_result = stream_fn(stream).await;
        let enc_final_result = match final_result {
            ::std::result::Result::Ok(ok_result) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodAndReponseSinkFinalExn>(
                    ::std::result::Result::Ok(ok_result),
                    "methodAndReponse",
                );
                ::fbthrift::SerializedStreamElement::Success(payload)
            }
            ::std::result::Result::Err(crate::services::sink_service::MethodAndReponseSinkFinalExn::ApplicationException(aexn)) => {
                tracing::info!(?aexn, method="SinkService.methodAndReponse", "Sink Final ApplicationException");
                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
            }
            
        };
        final_result_callback(enc_final_result);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "SinkService.methodThrow"))]
    async fn handle_methodThrow<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"SinkService";
        const METHOD_NAME: &::std::ffi::CStr = c"methodThrow";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"SinkService.methodThrow";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_SinkService_methodThrow = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.methodThrow(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "SinkService.methodThrow", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "SinkService.methodThrow", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodThrow", exn);
                ::tracing::error!(method = "SinkService.methodThrow", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::sink_service::MethodThrowExn::ApplicationException(aexn))
            }
        };

        // Process the Thrift SINK encoded request

        use ::futures::StreamExt as _;

        let (first_result, stream_fn, buffer_size, chunk_timeout): (
            ::std::result::Result::<(), crate::services::sink_service::MethodThrowExn>,
            ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodThrowSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodThrowSinkFinalExn>
            > + Send>,
            _,
            _,
        ) = match res {
            Ok(crate::errors::sink_service::MethodThrowSinkResult {
                stream_handler,
                buffer_size,
                chunk_timeout,
            }) => (::std::result::Result::Ok(()), stream_handler, buffer_size, chunk_timeout),
            Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodThrow", Box::new("Stream function builder failed to execute"));
                ::std::result::Result::Err(crate::services::sink_service::MethodThrowSinkFinalExn::ApplicationException(aexn))
            }.boxed()), 100, ::std::time::Duration::ZERO),
        };

        let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::sink_service::MethodThrowExn>(
            "methodThrow",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            first_result,
        )?;
        let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
        let stream =
            ::std::panic::AssertUnwindSafe(input_stream)
                .catch_unwind()
                .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                    match item {
                        ::std::result::Result::Err(exn) => {
                            tracing::error!(?exn, method="SinkService.methodThrow", "Sink stream unwind");
                            let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodThrow", exn);
                            ::std::result::Result::Err(crate::errors::sink_service::MethodThrowSinkExn::ApplicationException(aexn))
                        },
                        ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                            let mut de = P::deserializer(item_enc);
                            let res = <crate::errors::sink_service::MethodThrowSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                            match res {
                                Ok(r) => r,
                                Err(exn) => {
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodThrow", Box::new(exn));
                                    ::std::result::Result::Err(crate::errors::sink_service::MethodThrowSinkExn::ApplicationException(aexn))
                                }
                            }
                        },
                        ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                            ::std::result::Result::Err(crate::errors::sink_service::MethodThrowSinkExn::ApplicationException(aexn))
                        }
                    }
                )
                .boxed();
        let final_result = stream_fn(stream).await;
        let enc_final_result = match final_result {
            ::std::result::Result::Ok(ok_result) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodThrowSinkFinalExn>(
                    ::std::result::Result::Ok(ok_result),
                    "methodThrow",
                );
                ::fbthrift::SerializedStreamElement::Success(payload)
            }
            ::std::result::Result::Err(crate::services::sink_service::MethodThrowSinkFinalExn::ApplicationException(aexn)) => {
                tracing::info!(?aexn, method="SinkService.methodThrow", "Sink Final ApplicationException");
                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
            }
            
        };
        final_result_callback(enc_final_result);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "SinkService.methodSinkThrow"))]
    async fn handle_methodSinkThrow<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"SinkService";
        const METHOD_NAME: &::std::ffi::CStr = c"methodSinkThrow";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"SinkService.methodSinkThrow";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_SinkService_methodSinkThrow = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.methodSinkThrow(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "SinkService.methodSinkThrow", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "SinkService.methodSinkThrow", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodSinkThrow", exn);
                ::tracing::error!(method = "SinkService.methodSinkThrow", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::sink_service::MethodSinkThrowExn::ApplicationException(aexn))
            }
        };

        // Process the Thrift SINK encoded request

        use ::futures::StreamExt as _;

        let (first_result, stream_fn, buffer_size, chunk_timeout): (
            ::std::result::Result::<(), crate::services::sink_service::MethodSinkThrowExn>,
            ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodSinkThrowSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodSinkThrowSinkFinalExn>
            > + Send>,
            _,
            _,
        ) = match res {
            Ok(crate::errors::sink_service::MethodSinkThrowSinkResult {
                stream_handler,
                buffer_size,
                chunk_timeout,
            }) => (::std::result::Result::Ok(()), stream_handler, buffer_size, chunk_timeout),
            Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodSinkThrow", Box::new("Stream function builder failed to execute"));
                ::std::result::Result::Err(crate::services::sink_service::MethodSinkThrowSinkFinalExn::ApplicationException(aexn))
            }.boxed()), 100, ::std::time::Duration::ZERO),
        };

        let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::sink_service::MethodSinkThrowExn>(
            "methodSinkThrow",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            first_result,
        )?;
        let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
        let stream =
            ::std::panic::AssertUnwindSafe(input_stream)
                .catch_unwind()
                .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                    match item {
                        ::std::result::Result::Err(exn) => {
                            tracing::error!(?exn, method="SinkService.methodSinkThrow", "Sink stream unwind");
                            let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodSinkThrow", exn);
                            ::std::result::Result::Err(crate::errors::sink_service::MethodSinkThrowSinkExn::ApplicationException(aexn))
                        },
                        ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                            let mut de = P::deserializer(item_enc);
                            let res = <crate::errors::sink_service::MethodSinkThrowSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                            match res {
                                Ok(r) => r,
                                Err(exn) => {
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodSinkThrow", Box::new(exn));
                                    ::std::result::Result::Err(crate::errors::sink_service::MethodSinkThrowSinkExn::ApplicationException(aexn))
                                }
                            }
                        },
                        ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                            ::std::result::Result::Err(crate::errors::sink_service::MethodSinkThrowSinkExn::ApplicationException(aexn))
                        }
                    }
                )
                .boxed();
        let final_result = stream_fn(stream).await;
        let enc_final_result = match final_result {
            ::std::result::Result::Ok(ok_result) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodSinkThrowSinkFinalExn>(
                    ::std::result::Result::Ok(ok_result),
                    "methodSinkThrow",
                );
                ::fbthrift::SerializedStreamElement::Success(payload)
            }
            ::std::result::Result::Err(crate::services::sink_service::MethodSinkThrowSinkFinalExn::ApplicationException(aexn)) => {
                tracing::info!(?aexn, method="SinkService.methodSinkThrow", "Sink Final ApplicationException");
                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
            }
            
        };
        final_result_callback(enc_final_result);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "SinkService.methodFinalThrow"))]
    async fn handle_methodFinalThrow<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"SinkService";
        const METHOD_NAME: &::std::ffi::CStr = c"methodFinalThrow";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"SinkService.methodFinalThrow";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_SinkService_methodFinalThrow = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.methodFinalThrow(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "SinkService.methodFinalThrow", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "SinkService.methodFinalThrow", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodFinalThrow", exn);
                ::tracing::error!(method = "SinkService.methodFinalThrow", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::sink_service::MethodFinalThrowExn::ApplicationException(aexn))
            }
        };

        // Process the Thrift SINK encoded request

        use ::futures::StreamExt as _;

        let (first_result, stream_fn, buffer_size, chunk_timeout): (
            ::std::result::Result::<(), crate::services::sink_service::MethodFinalThrowExn>,
            ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodFinalThrowSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodFinalThrowSinkFinalExn>
            > + Send>,
            _,
            _,
        ) = match res {
            Ok(crate::errors::sink_service::MethodFinalThrowSinkResult {
                stream_handler,
                buffer_size,
                chunk_timeout,
            }) => (::std::result::Result::Ok(()), stream_handler, buffer_size, chunk_timeout),
            Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodFinalThrow", Box::new("Stream function builder failed to execute"));
                ::std::result::Result::Err(crate::services::sink_service::MethodFinalThrowSinkFinalExn::ApplicationException(aexn))
            }.boxed()), 100, ::std::time::Duration::ZERO),
        };

        let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::sink_service::MethodFinalThrowExn>(
            "methodFinalThrow",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            first_result,
        )?;
        let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
        let stream =
            ::std::panic::AssertUnwindSafe(input_stream)
                .catch_unwind()
                .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                    match item {
                        ::std::result::Result::Err(exn) => {
                            tracing::error!(?exn, method="SinkService.methodFinalThrow", "Sink stream unwind");
                            let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodFinalThrow", exn);
                            ::std::result::Result::Err(crate::errors::sink_service::MethodFinalThrowSinkExn::ApplicationException(aexn))
                        },
                        ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                            let mut de = P::deserializer(item_enc);
                            let res = <crate::errors::sink_service::MethodFinalThrowSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                            match res {
                                Ok(r) => r,
                                Err(exn) => {
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodFinalThrow", Box::new(exn));
                                    ::std::result::Result::Err(crate::errors::sink_service::MethodFinalThrowSinkExn::ApplicationException(aexn))
                                }
                            }
                        },
                        ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                            ::std::result::Result::Err(crate::errors::sink_service::MethodFinalThrowSinkExn::ApplicationException(aexn))
                        }
                    }
                )
                .boxed();
        let final_result = stream_fn(stream).await;
        let enc_final_result = match final_result {
            ::std::result::Result::Ok(ok_result) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodFinalThrowSinkFinalExn>(
                    ::std::result::Result::Ok(ok_result),
                    "methodFinalThrow",
                );
                ::fbthrift::SerializedStreamElement::Success(payload)
            }
            ::std::result::Result::Err(crate::services::sink_service::MethodFinalThrowSinkFinalExn::ApplicationException(aexn)) => {
                tracing::info!(?aexn, method="SinkService.methodFinalThrow", "Sink Final ApplicationException");
                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
            }
            ::std::result::Result::Err(exn) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodFinalThrowSinkFinalExn>(
                    ::std::result::Result::Err(exn),
                    "methodFinalThrow",
                );
                ::fbthrift::SerializedStreamElement::DeclaredException(payload)
            }
        };
        final_result_callback(enc_final_result);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "SinkService.methodBothThrow"))]
    async fn handle_methodBothThrow<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"SinkService";
        const METHOD_NAME: &::std::ffi::CStr = c"methodBothThrow";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"SinkService.methodBothThrow";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_SinkService_methodBothThrow = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.methodBothThrow(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "SinkService.methodBothThrow", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "SinkService.methodBothThrow", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodBothThrow", exn);
                ::tracing::error!(method = "SinkService.methodBothThrow", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::sink_service::MethodBothThrowExn::ApplicationException(aexn))
            }
        };

        // Process the Thrift SINK encoded request

        use ::futures::StreamExt as _;

        let (first_result, stream_fn, buffer_size, chunk_timeout): (
            ::std::result::Result::<(), crate::services::sink_service::MethodBothThrowExn>,
            ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodBothThrowSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodBothThrowSinkFinalExn>
            > + Send>,
            _,
            _,
        ) = match res {
            Ok(crate::errors::sink_service::MethodBothThrowSinkResult {
                stream_handler,
                buffer_size,
                chunk_timeout,
            }) => (::std::result::Result::Ok(()), stream_handler, buffer_size, chunk_timeout),
            Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodBothThrow", Box::new("Stream function builder failed to execute"));
                ::std::result::Result::Err(crate::services::sink_service::MethodBothThrowSinkFinalExn::ApplicationException(aexn))
            }.boxed()), 100, ::std::time::Duration::ZERO),
        };

        let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::sink_service::MethodBothThrowExn>(
            "methodBothThrow",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            first_result,
        )?;
        let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
        let stream =
            ::std::panic::AssertUnwindSafe(input_stream)
                .catch_unwind()
                .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                    match item {
                        ::std::result::Result::Err(exn) => {
                            tracing::error!(?exn, method="SinkService.methodBothThrow", "Sink stream unwind");
                            let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodBothThrow", exn);
                            ::std::result::Result::Err(crate::errors::sink_service::MethodBothThrowSinkExn::ApplicationException(aexn))
                        },
                        ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                            let mut de = P::deserializer(item_enc);
                            let res = <crate::errors::sink_service::MethodBothThrowSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                            match res {
                                Ok(r) => r,
                                Err(exn) => {
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodBothThrow", Box::new(exn));
                                    ::std::result::Result::Err(crate::errors::sink_service::MethodBothThrowSinkExn::ApplicationException(aexn))
                                }
                            }
                        },
                        ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                            ::std::result::Result::Err(crate::errors::sink_service::MethodBothThrowSinkExn::ApplicationException(aexn))
                        }
                    }
                )
                .boxed();
        let final_result = stream_fn(stream).await;
        let enc_final_result = match final_result {
            ::std::result::Result::Ok(ok_result) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodBothThrowSinkFinalExn>(
                    ::std::result::Result::Ok(ok_result),
                    "methodBothThrow",
                );
                ::fbthrift::SerializedStreamElement::Success(payload)
            }
            ::std::result::Result::Err(crate::services::sink_service::MethodBothThrowSinkFinalExn::ApplicationException(aexn)) => {
                tracing::info!(?aexn, method="SinkService.methodBothThrow", "Sink Final ApplicationException");
                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
            }
            ::std::result::Result::Err(exn) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodBothThrowSinkFinalExn>(
                    ::std::result::Result::Err(exn),
                    "methodBothThrow",
                );
                ::fbthrift::SerializedStreamElement::DeclaredException(payload)
            }
        };
        final_result_callback(enc_final_result);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "SinkService.methodFast"))]
    async fn handle_methodFast<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"SinkService";
        const METHOD_NAME: &::std::ffi::CStr = c"methodFast";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"SinkService.methodFast";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_SinkService_methodFast = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.methodFast(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "SinkService.methodFast", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "SinkService.methodFast", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodFast", exn);
                ::tracing::error!(method = "SinkService.methodFast", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::sink_service::MethodFastExn::ApplicationException(aexn))
            }
        };

        // Process the Thrift SINK encoded request

        use ::futures::StreamExt as _;

        let (first_result, stream_fn, buffer_size, chunk_timeout): (
            ::std::result::Result::<(), crate::services::sink_service::MethodFastExn>,
            ::std::boxed::Box<dyn ::std::ops::FnOnce(
                ::futures::stream::BoxStream<'static, ::std::result::Result<crate::types::SinkPayload, crate::services::sink_service::MethodFastSinkExn>>
            ) -> ::futures::future::BoxFuture<'static,
                ::std::result::Result<crate::types::FinalResponse, crate::services::sink_service::MethodFastSinkFinalExn>
            > + Send>,
            _,
            _,
        ) = match res {
            Ok(crate::errors::sink_service::MethodFastSinkResult {
                stream_handler,
                buffer_size,
                chunk_timeout,
            }) => (::std::result::Result::Ok(()), stream_handler, buffer_size, chunk_timeout),
            Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodFast", Box::new("Stream function builder failed to execute"));
                ::std::result::Result::Err(crate::services::sink_service::MethodFastSinkFinalExn::ApplicationException(aexn))
            }.boxed()), 100, ::std::time::Duration::ZERO),
        };

        let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::sink_service::MethodFastExn>(
            "methodFast",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            first_result,
        )?;
        let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
        let stream =
            ::std::panic::AssertUnwindSafe(input_stream)
                .catch_unwind()
                .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                    match item {
                        ::std::result::Result::Err(exn) => {
                            tracing::error!(?exn, method="SinkService.methodFast", "Sink stream unwind");
                            let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodFast", exn);
                            ::std::result::Result::Err(crate::errors::sink_service::MethodFastSinkExn::ApplicationException(aexn))
                        },
                        ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                            let mut de = P::deserializer(item_enc);
                            let res = <crate::errors::sink_service::MethodFastSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                            match res {
                                Ok(r) => r,
                                Err(exn) => {
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("SinkService.methodFast", Box::new(exn));
                                    ::std::result::Result::Err(crate::errors::sink_service::MethodFastSinkExn::ApplicationException(aexn))
                                }
                            }
                        },
                        ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                            ::std::result::Result::Err(crate::errors::sink_service::MethodFastSinkExn::ApplicationException(aexn))
                        }
                    }
                )
                .boxed();
        let final_result = stream_fn(stream).await;
        let enc_final_result = match final_result {
            ::std::result::Result::Ok(ok_result) => {
                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::sink_service::MethodFastSinkFinalExn>(
                    ::std::result::Result::Ok(ok_result),
                    "methodFast",
                );
                ::fbthrift::SerializedStreamElement::Success(payload)
            }
            ::std::result::Result::Err(crate::services::sink_service::MethodFastSinkFinalExn::ApplicationException(aexn)) => {
                tracing::info!(?aexn, method="SinkService.methodFast", "Sink Final ApplicationException");
                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
            }
            
        };
        final_result_callback(enc_final_result);
        ::std::result::Result::Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for SinkServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: SinkService,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"method" => ::std::result::Result::Ok(0usize),
            b"methodAndReponse" => ::std::result::Result::Ok(1usize),
            b"methodThrow" => ::std::result::Result::Ok(2usize),
            b"methodSinkThrow" => ::std::result::Result::Ok(3usize),
            b"methodFinalThrow" => ::std::result::Result::Ok(4usize),
            b"methodBothThrow" => ::std::result::Result::Ok(5usize),
            b"methodFast" => ::std::result::Result::Ok(6usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_method(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            1usize => {
                self.handle_methodAndReponse(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            2usize => {
                self.handle_methodThrow(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            3usize => {
                self.handle_methodSinkThrow(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            4usize => {
                self.handle_methodFinalThrow(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            5usize => {
                self.handle_methodBothThrow(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            6usize => {
                self.handle_methodFast(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "SinkServiceProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "SinkServiceProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for SinkServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: SinkService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "SinkService"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        ::std::result::Result::Ok(())
    }

    fn create_interaction(
        &self,
        name: &::std::primitive::str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
        &[
            // From module.SinkService:
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "method",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "methodAndReponse",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "methodThrow",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "methodSinkThrow",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "methodFinalThrow",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "methodBothThrow",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "methodFast",
              starts_interaction: false,
              interaction_name: None,
            },
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a SinkService service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_SinkService_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: SinkService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(SinkServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(SinkServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "SinkService.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

