#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/types/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import annotations

from collections.abc import Mapping, Sequence, Set
import enum
import importlib
from builtins import property as _python__property

import typing as _typing
import folly.iobuf as _fbthrift_iobuf
import thrift.py3.types
from thrift.py3.types import (
    _fbthrift__round_float32,
    _fbthrift__is_float32,
    _fbthrift__filter_kwargs,
)
import thrift.py3.exceptions
import thrift.python.exceptions
import thrift.python.types
import apache.thrift.fixtures.types.module.thrift_types as _fbthrift_python_types
import apache.thrift.fixtures.types.module.thrift_enums as _fbthrift_python_enums


import apache.thrift.fixtures.types.included.types_inplace_FBTHRIFT_ONLY_DO_NOT_USE as _apache_thrift_fixtures_types_included_types

def get_types_reflection():
    return importlib.import_module(
        "apache.thrift.fixtures.types.module.types_reflection"
    )

def _get_py_deprecated_module():
    import thrift.util.converter # needed by _to_py_deprecated() call
    return importlib.import_module("module.ttypes")

_fbthrift__module_name__ = "apache.thrift.fixtures.types.module.types"

__all__ = []

### Enums ###

has_bitwise_ops = _fbthrift_python_enums.has_bitwise_ops

__all__.append("has_bitwise_ops")


is_unscoped = _fbthrift_python_enums.is_unscoped

__all__.append("is_unscoped")


MyForwardRefEnum = _fbthrift_python_enums.MyForwardRefEnum

__all__.append("MyForwardRefEnum")


### Union Enums ###

### Containers ###
class std_unordered_map__Map__i32_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = False

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, std_unordered_map__Map__i32_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = std_unordered_map__Map__i32_string._check_key_type_or_raise
            check_val = std_unordered_map__Map__i32_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, std_unordered_map__Map__i32_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_unordered_map__Map__i32_string()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> std_unordered_map__Map__i32_string:
        _keys = python_map.keys()
        _values = python_map.values()
        return std_unordered_map__Map__i32_string(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(std_unordered_map__Map__i32_string)

__all__.append("std_unordered_map__Map__i32_string")

class List__i64(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i64):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i64._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i64)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i64()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__i64:
        _items = list(python_list)
        return List__i64(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__i64)


__all__.append("List__i64")

class Map__binary_i64(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__binary_i64):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__binary_i64._check_key_type_or_raise
            check_val = Map__binary_i64._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__binary_i64)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, bytes)
        ):
            raise TypeError(f"{key!r} is not of type bytes")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, bytes):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__binary_i64()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__binary_i64:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__binary_i64(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__binary_i64)

__all__.append("Map__binary_i64")

class List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__i32:
        _items = list(python_list)
        return List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__i32)


__all__.append("List__i32")

class std_list__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_list__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = std_list__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, std_list__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_list__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> std_list__List__i32:
        _items = list(python_list)
        return std_list__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(std_list__List__i32)


__all__.append("std_list__List__i32")

class std_deque__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_deque__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = std_deque__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, std_deque__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_deque__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> std_deque__List__i32:
        _items = list(python_list)
        return std_deque__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(std_deque__List__i32)


__all__.append("std_deque__List__i32")

class folly_fbvector__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_fbvector__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = folly_fbvector__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, folly_fbvector__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_fbvector__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> folly_fbvector__List__i32:
        _items = list(python_list)
        return folly_fbvector__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(folly_fbvector__List__i32)


__all__.append("folly_fbvector__List__i32")

class folly_small_vector__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_small_vector__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = folly_small_vector__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, folly_small_vector__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_small_vector__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> folly_small_vector__List__i32:
        _items = list(python_list)
        return folly_small_vector__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(folly_small_vector__List__i32)


__all__.append("folly_small_vector__List__i32")

class folly_sorted_vector_set__Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_sorted_vector_set__Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = folly_sorted_vector_set__Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, folly_sorted_vector_set__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_sorted_vector_set__Set__i32()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> folly_sorted_vector_set__Set__i32:
        _items = frozenset(python_set)
        return folly_sorted_vector_set__Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(folly_sorted_vector_set__Set__i32)


__all__.append("folly_sorted_vector_set__Set__i32")

class Map__i32_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_string._check_key_type_or_raise
            check_val = Map__i32_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_string()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_string:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__i32_string(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_string)

__all__.append("Map__i32_string")

class std_list_int32_t__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_list_int32_t__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = std_list_int32_t__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, std_list_int32_t__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_list_int32_t__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> std_list_int32_t__List__i32:
        _items = list(python_list)
        return std_list_int32_t__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(std_list_int32_t__List__i32)


__all__.append("std_list_int32_t__List__i32")

class Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i32._check_key_type_or_raise
            check_val = Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__string_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_i32)

__all__.append("Map__string_i32")

class List__std_unordered_map__Map__i32_string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__std_unordered_map__Map__i32_string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__std_unordered_map__Map__i32_string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__std_unordered_map__Map__i32_string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[int, str]")
        if not isinstance(item, std_unordered_map__Map__i32_string):
            item = std_unordered_map__Map__i32_string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, std_unordered_map__Map__i32_string):
            return item
        try:
            return std_unordered_map__Map__i32_string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__std_unordered_map__Map__i32_string()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__std_unordered_map__Map__i32_string:
        _items = [
            std_unordered_map__Map__i32_string.from_python(item)
            for item in python_list
        ]
        return List__std_unordered_map__Map__i32_string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__std_unordered_map__Map__i32_string)


__all__.append("List__std_unordered_map__Map__i32_string")

class Map__i32_IncompleteMapDep(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_IncompleteMapDep):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_IncompleteMapDep._check_key_type_or_raise
            check_val = Map__i32_IncompleteMapDep._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_IncompleteMapDep)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, IncompleteMapDep)
        ):
            raise TypeError(f"{item!r} is not of type IncompleteMapDep")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_IncompleteMapDep()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_IncompleteMapDep:
        _keys = python_map.keys()
        _values = (
            IncompleteMapDep.from_python(item)
            for item in python_map.values()
        )
        return Map__i32_IncompleteMapDep(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_IncompleteMapDep)

__all__.append("Map__i32_IncompleteMapDep")

class std_unordered_map__Map__i32_CompleteMapDep(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = False

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, std_unordered_map__Map__i32_CompleteMapDep):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = std_unordered_map__Map__i32_CompleteMapDep._check_key_type_or_raise
            check_val = std_unordered_map__Map__i32_CompleteMapDep._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, std_unordered_map__Map__i32_CompleteMapDep)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, CompleteMapDep)
        ):
            raise TypeError(f"{item!r} is not of type CompleteMapDep")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_unordered_map__Map__i32_CompleteMapDep()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> std_unordered_map__Map__i32_CompleteMapDep:
        _keys = python_map.keys()
        _values = (
            CompleteMapDep.from_python(item)
            for item in python_map.values()
        )
        return std_unordered_map__Map__i32_CompleteMapDep(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(std_unordered_map__Map__i32_CompleteMapDep)

__all__.append("std_unordered_map__Map__i32_CompleteMapDep")

class _std_list__List__IncompleteListDep(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, _std_list__List__IncompleteListDep):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = _std_list__List__IncompleteListDep._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, _std_list__List__IncompleteListDep)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, IncompleteListDep)
        ):
            raise TypeError(f"{item!r} is not of type IncompleteListDep")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, IncompleteListDep):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___std_list__List__IncompleteListDep()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> _std_list__List__IncompleteListDep:
        _items = [
            IncompleteListDep.from_python(item)
            for item in python_list
        ]
        return _std_list__List__IncompleteListDep(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(_std_list__List__IncompleteListDep)


__all__.append("_std_list__List__IncompleteListDep")

class folly_small_vector__List__CompleteListDep(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_small_vector__List__CompleteListDep):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = folly_small_vector__List__CompleteListDep._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, folly_small_vector__List__CompleteListDep)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, CompleteListDep)
        ):
            raise TypeError(f"{item!r} is not of type CompleteListDep")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, CompleteListDep):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_small_vector__List__CompleteListDep()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> folly_small_vector__List__CompleteListDep:
        _items = [
            CompleteListDep.from_python(item)
            for item in python_list
        ]
        return folly_small_vector__List__CompleteListDep(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(folly_small_vector__List__CompleteListDep)


__all__.append("folly_small_vector__List__CompleteListDep")

class List__AdaptedListDep(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__AdaptedListDep):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__AdaptedListDep._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__AdaptedListDep)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, AdaptedListDep)
        ):
            raise TypeError(f"{item!r} is not of type AdaptedListDep")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, AdaptedListDep):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__AdaptedListDep()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__AdaptedListDep:
        _items = [
            AdaptedListDep.from_python(item)
            for item in python_list
        ]
        return List__AdaptedListDep(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__AdaptedListDep)


__all__.append("List__AdaptedListDep")

class List__DependentAdaptedListDep(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__DependentAdaptedListDep):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__DependentAdaptedListDep._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__DependentAdaptedListDep)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, DependentAdaptedListDep)
        ):
            raise TypeError(f"{item!r} is not of type DependentAdaptedListDep")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, DependentAdaptedListDep):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__DependentAdaptedListDep()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__DependentAdaptedListDep:
        _items = [
            DependentAdaptedListDep.from_python(item)
            for item in python_list
        ]
        return List__DependentAdaptedListDep(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__DependentAdaptedListDep)


__all__.append("List__DependentAdaptedListDep")

class Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__i32()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> Set__i32:
        _items = frozenset(python_set)
        return Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(Set__i32)


__all__.append("Set__i32")

class Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_i32._check_key_type_or_raise
            check_val = Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__i32_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_i32)

__all__.append("Map__i32_i32")


### Structured Types ###
class empty_struct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.empty_struct
    _FBTHRIFT__FIELD_NAMES = (
    )
    _fbthrift__inner : _fbthrift_python_types.empty_struct


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.empty_struct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.empty_struct(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> empty_struct:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> empty_struct:
        return empty_struct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.empty_struct) -> empty_struct:
        inst = empty_struct.__new__(empty_struct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> empty_struct:
        return self

    def _to_python(self) -> _fbthrift_python_types.empty_struct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.empty_struct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__empty_struct()

    @staticmethod
    def __get_metadata__():
        return empty_struct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.empty_struct"


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 0

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, empty_struct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, empty_struct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("empty_struct")

class decorated_struct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.decorated_struct
    _FBTHRIFT__FIELD_NAMES = (
        "field",
    )
    _fbthrift__inner : _fbthrift_python_types.decorated_struct


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.decorated_struct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.decorated_struct(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> decorated_struct:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> decorated_struct:
        return decorated_struct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.decorated_struct) -> decorated_struct:
        inst = decorated_struct.__new__(decorated_struct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> decorated_struct:
        return self

    def _to_python(self) -> _fbthrift_python_types.decorated_struct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.decorated_struct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__decorated_struct()

    @staticmethod
    def __get_metadata__():
        return decorated_struct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.decorated_struct"

    @_python__property
    def field(self) -> str:
        return self._fbthrift__inner.field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, decorated_struct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, decorated_struct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("decorated_struct")

class ContainerStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__fieldA",
        "_fbthrift_inner__fieldB",
        "_fbthrift_inner__fieldC",
        "_fbthrift_inner__fieldD",
        "_fbthrift_inner__fieldE",
        "_fbthrift_inner__fieldF",
        "_fbthrift_inner__fieldG",
        "_fbthrift_inner__fieldH",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.ContainerStruct
    _FBTHRIFT__FIELD_NAMES = (
        "fieldA",
        "fieldB",
        "fieldC",
        "fieldD",
        "fieldE",
        "fieldF",
        "fieldG",
        "fieldH",
    )
    _fbthrift__inner : _fbthrift_python_types.ContainerStruct
    _fbthrift_inner__fieldA : _typing.Sequence[int] | None
    _fbthrift_inner__fieldB : _typing.Sequence[int] | None
    _fbthrift_inner__fieldC : _typing.Sequence[int] | None
    _fbthrift_inner__fieldD : _typing.Sequence[int] | None
    _fbthrift_inner__fieldE : _typing.Sequence[int] | None
    _fbthrift_inner__fieldF : _typing.AbstractSet[int] | None
    _fbthrift_inner__fieldG : _typing.Mapping[int, str] | None
    _fbthrift_inner__fieldH : _typing.Mapping[int, str] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.ContainerStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.ContainerStruct(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> ContainerStruct:
        instance = super().__new__(cls)
        instance._fbthrift_inner__fieldA = None
        instance._fbthrift_inner__fieldB = None
        instance._fbthrift_inner__fieldC = None
        instance._fbthrift_inner__fieldD = None
        instance._fbthrift_inner__fieldE = None
        instance._fbthrift_inner__fieldF = None
        instance._fbthrift_inner__fieldG = None
        instance._fbthrift_inner__fieldH = None
        return instance

    def __call__(self, **kwargs) -> ContainerStruct:
        return ContainerStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.ContainerStruct) -> ContainerStruct:
        inst = ContainerStruct.__new__(ContainerStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> ContainerStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.ContainerStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.ContainerStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__ContainerStruct()

    @staticmethod
    def __get_metadata__():
        return ContainerStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.ContainerStruct"

    @_python__property
    def fieldA(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__fieldA is None:
            __python_val = self._fbthrift__inner.fieldA
            self._fbthrift_inner__fieldA = List__i32.from_python(__python_val)

        return self._fbthrift_inner__fieldA

    @_python__property
    def fieldB(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__fieldB is None:
            __python_val = self._fbthrift__inner.fieldB
            self._fbthrift_inner__fieldB = std_list__List__i32.from_python(__python_val)

        return self._fbthrift_inner__fieldB

    @_python__property
    def fieldC(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__fieldC is None:
            __python_val = self._fbthrift__inner.fieldC
            self._fbthrift_inner__fieldC = std_deque__List__i32.from_python(__python_val)

        return self._fbthrift_inner__fieldC

    @_python__property
    def fieldD(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__fieldD is None:
            __python_val = self._fbthrift__inner.fieldD
            self._fbthrift_inner__fieldD = folly_fbvector__List__i32.from_python(__python_val)

        return self._fbthrift_inner__fieldD

    @_python__property
    def fieldE(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__fieldE is None:
            __python_val = self._fbthrift__inner.fieldE
            self._fbthrift_inner__fieldE = folly_small_vector__List__i32.from_python(__python_val)

        return self._fbthrift_inner__fieldE

    @_python__property
    def fieldF(self) -> _typing.AbstractSet[int]:
        if self._fbthrift_inner__fieldF is None:
            __python_val = self._fbthrift__inner.fieldF
            self._fbthrift_inner__fieldF = folly_sorted_vector_set__Set__i32.from_python(__python_val)

        return self._fbthrift_inner__fieldF

    @_python__property
    def fieldG(self) -> _typing.Mapping[int, str]:
        if self._fbthrift_inner__fieldG is None:
            __python_val = self._fbthrift__inner.fieldG
            self._fbthrift_inner__fieldG = Map__i32_string.from_python(__python_val)

        return self._fbthrift_inner__fieldG

    @_python__property
    def fieldH(self) -> _typing.Mapping[int, str]:
        if self._fbthrift_inner__fieldH is None:
            __python_val = self._fbthrift__inner.fieldH
            self._fbthrift_inner__fieldH = std_unordered_map__Map__i32_string.from_python(__python_val)

        return self._fbthrift_inner__fieldH


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 8

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, ContainerStruct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, ContainerStruct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("ContainerStruct")

class CppTypeStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__fieldA",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.CppTypeStruct
    _FBTHRIFT__FIELD_NAMES = (
        "fieldA",
    )
    _fbthrift__inner : _fbthrift_python_types.CppTypeStruct
    _fbthrift_inner__fieldA : _typing.Sequence[int] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.CppTypeStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.CppTypeStruct(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> CppTypeStruct:
        instance = super().__new__(cls)
        instance._fbthrift_inner__fieldA = None
        return instance

    def __call__(self, **kwargs) -> CppTypeStruct:
        return CppTypeStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.CppTypeStruct) -> CppTypeStruct:
        inst = CppTypeStruct.__new__(CppTypeStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> CppTypeStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.CppTypeStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.CppTypeStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__CppTypeStruct()

    @staticmethod
    def __get_metadata__():
        return CppTypeStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.CppTypeStruct"

    @_python__property
    def fieldA(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__fieldA is None:
            __python_val = self._fbthrift__inner.fieldA
            self._fbthrift_inner__fieldA = std_list_int32_t__List__i32.from_python(__python_val)

        return self._fbthrift_inner__fieldA


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, CppTypeStruct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, CppTypeStruct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("CppTypeStruct")

class VirtualStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.VirtualStruct
    _FBTHRIFT__FIELD_NAMES = (
        "MyIntField",
    )
    _fbthrift__inner : _fbthrift_python_types.VirtualStruct


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.VirtualStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.VirtualStruct(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> VirtualStruct:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> VirtualStruct:
        return VirtualStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.VirtualStruct) -> VirtualStruct:
        inst = VirtualStruct.__new__(VirtualStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> VirtualStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.VirtualStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.VirtualStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__VirtualStruct()

    @staticmethod
    def __get_metadata__():
        return VirtualStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.VirtualStruct"

    @_python__property
    def MyIntField(self) -> int:
        return self._fbthrift__inner.MyIntField


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, VirtualStruct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, VirtualStruct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("VirtualStruct")

class MyStructWithForwardRefEnum(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.MyStructWithForwardRefEnum
    _FBTHRIFT__FIELD_NAMES = (
        "a",
        "b",
    )
    _fbthrift__inner : _fbthrift_python_types.MyStructWithForwardRefEnum


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.MyStructWithForwardRefEnum(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.MyStructWithForwardRefEnum(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> MyStructWithForwardRefEnum:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> MyStructWithForwardRefEnum:
        return MyStructWithForwardRefEnum.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.MyStructWithForwardRefEnum) -> MyStructWithForwardRefEnum:
        inst = MyStructWithForwardRefEnum.__new__(MyStructWithForwardRefEnum)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> MyStructWithForwardRefEnum:
        return self

    def _to_python(self) -> _fbthrift_python_types.MyStructWithForwardRefEnum:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.MyStructWithForwardRefEnum, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__MyStructWithForwardRefEnum()

    @staticmethod
    def __get_metadata__():
        return MyStructWithForwardRefEnum._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.MyStructWithForwardRefEnum"

    @_python__property
    def a(self) -> MyForwardRefEnum:
        return self._fbthrift__inner.a

    @_python__property
    def b(self) -> MyForwardRefEnum:
        return self._fbthrift__inner.b


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, MyStructWithForwardRefEnum):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, MyStructWithForwardRefEnum):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("MyStructWithForwardRefEnum")

class TrivialNumeric(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.TrivialNumeric
    _FBTHRIFT__FIELD_NAMES = (
        "a",
        "b",
    )
    _fbthrift__inner : _fbthrift_python_types.TrivialNumeric


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.TrivialNumeric(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.TrivialNumeric(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> TrivialNumeric:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> TrivialNumeric:
        return TrivialNumeric.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.TrivialNumeric) -> TrivialNumeric:
        inst = TrivialNumeric.__new__(TrivialNumeric)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> TrivialNumeric:
        return self

    def _to_python(self) -> _fbthrift_python_types.TrivialNumeric:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.TrivialNumeric, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__TrivialNumeric()

    @staticmethod
    def __get_metadata__():
        return TrivialNumeric._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.TrivialNumeric"

    @_python__property
    def a(self) -> int:
        return self._fbthrift__inner.a

    @_python__property
    def b(self) -> bool:
        return self._fbthrift__inner.b


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, TrivialNumeric):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, TrivialNumeric):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("TrivialNumeric")

class TrivialNestedWithDefault(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__n",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.TrivialNestedWithDefault
    _FBTHRIFT__FIELD_NAMES = (
        "z",
        "n",
    )
    _fbthrift__inner : _fbthrift_python_types.TrivialNestedWithDefault
    _fbthrift_inner__n : TrivialNumeric | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.TrivialNestedWithDefault(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.TrivialNestedWithDefault(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> TrivialNestedWithDefault:
        instance = super().__new__(cls)
        instance._fbthrift_inner__n = None
        return instance

    def __call__(self, **kwargs) -> TrivialNestedWithDefault:
        return TrivialNestedWithDefault.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.TrivialNestedWithDefault) -> TrivialNestedWithDefault:
        inst = TrivialNestedWithDefault.__new__(TrivialNestedWithDefault)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> TrivialNestedWithDefault:
        return self

    def _to_python(self) -> _fbthrift_python_types.TrivialNestedWithDefault:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.TrivialNestedWithDefault, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__TrivialNestedWithDefault()

    @staticmethod
    def __get_metadata__():
        return TrivialNestedWithDefault._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.TrivialNestedWithDefault"

    @_python__property
    def z(self) -> int:
        return self._fbthrift__inner.z

    @_python__property
    def n(self) -> TrivialNumeric:
        if self._fbthrift_inner__n is None:
            __python_val = self._fbthrift__inner.n
            self._fbthrift_inner__n = TrivialNumeric.from_python(__python_val)

        return self._fbthrift_inner__n


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, TrivialNestedWithDefault):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, TrivialNestedWithDefault):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("TrivialNestedWithDefault")

class ComplexString(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__b",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.ComplexString
    _FBTHRIFT__FIELD_NAMES = (
        "a",
        "b",
    )
    _fbthrift__inner : _fbthrift_python_types.ComplexString
    _fbthrift_inner__b : _typing.Mapping[str, int] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.ComplexString(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.ComplexString(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> ComplexString:
        instance = super().__new__(cls)
        instance._fbthrift_inner__b = None
        return instance

    def __call__(self, **kwargs) -> ComplexString:
        return ComplexString.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.ComplexString) -> ComplexString:
        inst = ComplexString.__new__(ComplexString)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> ComplexString:
        return self

    def _to_python(self) -> _fbthrift_python_types.ComplexString:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.ComplexString, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__ComplexString()

    @staticmethod
    def __get_metadata__():
        return ComplexString._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.ComplexString"

    @_python__property
    def a(self) -> str:
        return self._fbthrift__inner.a

    @_python__property
    def b(self) -> _typing.Mapping[str, int]:
        if self._fbthrift_inner__b is None:
            __python_val = self._fbthrift__inner.b
            self._fbthrift_inner__b = Map__string_i32.from_python(__python_val)

        return self._fbthrift_inner__b


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, ComplexString):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, ComplexString):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("ComplexString")

class ComplexNestedWithDefault(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__n",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.ComplexNestedWithDefault
    _FBTHRIFT__FIELD_NAMES = (
        "z",
        "n",
    )
    _fbthrift__inner : _fbthrift_python_types.ComplexNestedWithDefault
    _fbthrift_inner__n : ComplexString | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.ComplexNestedWithDefault(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.ComplexNestedWithDefault(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> ComplexNestedWithDefault:
        instance = super().__new__(cls)
        instance._fbthrift_inner__n = None
        return instance

    def __call__(self, **kwargs) -> ComplexNestedWithDefault:
        return ComplexNestedWithDefault.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.ComplexNestedWithDefault) -> ComplexNestedWithDefault:
        inst = ComplexNestedWithDefault.__new__(ComplexNestedWithDefault)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> ComplexNestedWithDefault:
        return self

    def _to_python(self) -> _fbthrift_python_types.ComplexNestedWithDefault:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.ComplexNestedWithDefault, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__ComplexNestedWithDefault()

    @staticmethod
    def __get_metadata__():
        return ComplexNestedWithDefault._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.ComplexNestedWithDefault"

    @_python__property
    def z(self) -> str:
        return self._fbthrift__inner.z

    @_python__property
    def n(self) -> ComplexString:
        if self._fbthrift_inner__n is None:
            __python_val = self._fbthrift__inner.n
            self._fbthrift_inner__n = ComplexString.from_python(__python_val)

        return self._fbthrift_inner__n


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, ComplexNestedWithDefault):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, ComplexNestedWithDefault):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("ComplexNestedWithDefault")

class MinPadding(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.MinPadding
    _FBTHRIFT__FIELD_NAMES = (
        "small",
        "big",
        "medium",
        "biggish",
        "tiny",
    )
    _fbthrift__inner : _fbthrift_python_types.MinPadding


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.MinPadding(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.MinPadding(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> MinPadding:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> MinPadding:
        return MinPadding.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.MinPadding) -> MinPadding:
        inst = MinPadding.__new__(MinPadding)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> MinPadding:
        return self

    def _to_python(self) -> _fbthrift_python_types.MinPadding:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.MinPadding, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__MinPadding()

    @staticmethod
    def __get_metadata__():
        return MinPadding._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.MinPadding"

    @_python__property
    def small(self) -> int:
        return self._fbthrift__inner.small

    @_python__property
    def big(self) -> int:
        return self._fbthrift__inner.big

    @_python__property
    def medium(self) -> int:
        return self._fbthrift__inner.medium

    @_python__property
    def biggish(self) -> int:
        return self._fbthrift__inner.biggish

    @_python__property
    def tiny(self) -> int:
        return self._fbthrift__inner.tiny


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 5

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, MinPadding):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, MinPadding):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("MinPadding")

class MinPaddingWithCustomType(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.MinPaddingWithCustomType
    _FBTHRIFT__FIELD_NAMES = (
        "small",
        "biggish",
        "medium",
        "big",
        "tiny",
    )
    _fbthrift__inner : _fbthrift_python_types.MinPaddingWithCustomType


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.MinPaddingWithCustomType(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.MinPaddingWithCustomType(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> MinPaddingWithCustomType:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> MinPaddingWithCustomType:
        return MinPaddingWithCustomType.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.MinPaddingWithCustomType) -> MinPaddingWithCustomType:
        inst = MinPaddingWithCustomType.__new__(MinPaddingWithCustomType)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> MinPaddingWithCustomType:
        return self

    def _to_python(self) -> _fbthrift_python_types.MinPaddingWithCustomType:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.MinPaddingWithCustomType, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__MinPaddingWithCustomType()

    @staticmethod
    def __get_metadata__():
        return MinPaddingWithCustomType._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.MinPaddingWithCustomType"

    @_python__property
    def small(self) -> int:
        return self._fbthrift__inner.small

    @_python__property
    def biggish(self) -> int:
        return self._fbthrift__inner.biggish

    @_python__property
    def medium(self) -> int:
        return self._fbthrift__inner.medium

    @_python__property
    def big(self) -> int:
        return self._fbthrift__inner.big

    @_python__property
    def tiny(self) -> int:
        return self._fbthrift__inner.tiny


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 5

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, MinPaddingWithCustomType):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, MinPaddingWithCustomType):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("MinPaddingWithCustomType")

class MyStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__data",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.MyStruct
    _FBTHRIFT__FIELD_NAMES = (
        "MyIntField",
        "MyStringField",
        "majorVer",
        "data",
    )
    _fbthrift__inner : _fbthrift_python_types.MyStruct
    _fbthrift_inner__data : MyDataItem | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.MyStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.MyStruct(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> MyStruct:
        instance = super().__new__(cls)
        instance._fbthrift_inner__data = None
        return instance

    def __call__(self, **kwargs) -> MyStruct:
        return MyStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.MyStruct) -> MyStruct:
        inst = MyStruct.__new__(MyStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> MyStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.MyStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.MyStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__MyStruct()

    @staticmethod
    def __get_metadata__():
        return MyStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.MyStruct"

    @_python__property
    def MyIntField(self) -> int:
        return self._fbthrift__inner.MyIntField

    @_python__property
    def MyStringField(self) -> str:
        return self._fbthrift__inner.MyStringField

    @_python__property
    def majorVer(self) -> int:
        return self._fbthrift__inner.majorVer

    @_python__property
    def data(self) -> MyDataItem:
        if self._fbthrift_inner__data is None:
            __python_val = self._fbthrift__inner.data
            self._fbthrift_inner__data = MyDataItem.from_python(__python_val)

        return self._fbthrift_inner__data


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 4

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, MyStruct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, MyStruct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("MyStruct")

class MyDataItem(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.MyDataItem
    _FBTHRIFT__FIELD_NAMES = (
    )
    _fbthrift__inner : _fbthrift_python_types.MyDataItem


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.MyDataItem(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.MyDataItem(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> MyDataItem:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> MyDataItem:
        return MyDataItem.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.MyDataItem) -> MyDataItem:
        inst = MyDataItem.__new__(MyDataItem)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> MyDataItem:
        return self

    def _to_python(self) -> _fbthrift_python_types.MyDataItem:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.MyDataItem, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__MyDataItem()

    @staticmethod
    def __get_metadata__():
        return MyDataItem._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.MyDataItem"


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 0

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, MyDataItem):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, MyDataItem):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("MyDataItem")

class Renaming(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.Renaming
    _FBTHRIFT__FIELD_NAMES = (
        "foo",
    )
    _fbthrift__inner : _fbthrift_python_types.Renaming


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.Renaming(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.Renaming(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> Renaming:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> Renaming:
        return Renaming.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.Renaming) -> Renaming:
        inst = Renaming.__new__(Renaming)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> Renaming:
        return self

    def _to_python(self) -> _fbthrift_python_types.Renaming:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.Renaming, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Renaming()

    @staticmethod
    def __get_metadata__():
        return Renaming._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.Renaming"

    @_python__property
    def foo(self) -> int:
        return self._fbthrift__inner.foo


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, Renaming):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, Renaming):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("Renaming")

class AnnotatedTypes(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__list_field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.AnnotatedTypes
    _FBTHRIFT__FIELD_NAMES = (
        "binary_field",
        "list_field",
    )
    _fbthrift__inner : _fbthrift_python_types.AnnotatedTypes
    _fbthrift_inner__list_field : _typing.Sequence[_typing.Mapping[int, str]] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.AnnotatedTypes(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.AnnotatedTypes(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> AnnotatedTypes:
        instance = super().__new__(cls)
        instance._fbthrift_inner__list_field = None
        return instance

    def __call__(self, **kwargs) -> AnnotatedTypes:
        return AnnotatedTypes.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.AnnotatedTypes) -> AnnotatedTypes:
        inst = AnnotatedTypes.__new__(AnnotatedTypes)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> AnnotatedTypes:
        return self

    def _to_python(self) -> _fbthrift_python_types.AnnotatedTypes:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.AnnotatedTypes, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__AnnotatedTypes()

    @staticmethod
    def __get_metadata__():
        return AnnotatedTypes._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.AnnotatedTypes"

    @_python__property
    def binary_field(self) -> bytes:
        return self._fbthrift__inner.binary_field

    @_python__property
    def list_field(self) -> _typing.Sequence[_typing.Mapping[int, str]]:
        if self._fbthrift_inner__list_field is None:
            __python_val = self._fbthrift__inner.list_field
            self._fbthrift_inner__list_field = List__std_unordered_map__Map__i32_string.from_python(__python_val)

        return self._fbthrift_inner__list_field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, AnnotatedTypes):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, AnnotatedTypes):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("AnnotatedTypes")

class ForwardUsageRoot(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__ForwardUsageStruct",
        "_fbthrift_inner__ForwardUsageByRef",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.ForwardUsageRoot
    _FBTHRIFT__FIELD_NAMES = (
        "ForwardUsageStruct",
        "ForwardUsageByRef",
    )
    _fbthrift__inner : _fbthrift_python_types.ForwardUsageRoot
    _fbthrift_inner__ForwardUsageStruct : _typing.Optional[ForwardUsageStruct] | None
    _fbthrift_inner__ForwardUsageByRef : _typing.Optional[ForwardUsageByRef] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.ForwardUsageRoot(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.ForwardUsageRoot(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> ForwardUsageRoot:
        instance = super().__new__(cls)
        instance._fbthrift_inner__ForwardUsageStruct = None
        instance._fbthrift_inner__ForwardUsageByRef = None
        return instance

    def __call__(self, **kwargs) -> ForwardUsageRoot:
        return ForwardUsageRoot.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.ForwardUsageRoot) -> ForwardUsageRoot:
        inst = ForwardUsageRoot.__new__(ForwardUsageRoot)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> ForwardUsageRoot:
        return self

    def _to_python(self) -> _fbthrift_python_types.ForwardUsageRoot:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.ForwardUsageRoot, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__ForwardUsageRoot()

    @staticmethod
    def __get_metadata__():
        return ForwardUsageRoot._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.ForwardUsageRoot"

    @_python__property
    def ForwardUsageStruct(self) -> _typing.Optional[ForwardUsageStruct]:
        if self._fbthrift_inner__ForwardUsageStruct is None:
            __python_val = self._fbthrift__inner.ForwardUsageStruct
            if __python_val is None:
                return None
            self._fbthrift_inner__ForwardUsageStruct = ForwardUsageStruct.from_python(__python_val)

        return self._fbthrift_inner__ForwardUsageStruct

    @_python__property
    def ForwardUsageByRef(self) -> _typing.Optional[ForwardUsageByRef]:
        if self._fbthrift_inner__ForwardUsageByRef is None:
            __python_val = self._fbthrift__inner.ForwardUsageByRef
            if __python_val is None:
                return None
            self._fbthrift_inner__ForwardUsageByRef = ForwardUsageByRef.from_python(__python_val)

        return self._fbthrift_inner__ForwardUsageByRef


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, ForwardUsageRoot):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, ForwardUsageRoot):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("ForwardUsageRoot")

class ForwardUsageStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__foo",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.ForwardUsageStruct
    _FBTHRIFT__FIELD_NAMES = (
        "foo",
    )
    _fbthrift__inner : _fbthrift_python_types.ForwardUsageStruct
    _fbthrift_inner__foo : _typing.Optional[ForwardUsageRoot] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.ForwardUsageStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.ForwardUsageStruct(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> ForwardUsageStruct:
        instance = super().__new__(cls)
        instance._fbthrift_inner__foo = None
        return instance

    def __call__(self, **kwargs) -> ForwardUsageStruct:
        return ForwardUsageStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.ForwardUsageStruct) -> ForwardUsageStruct:
        inst = ForwardUsageStruct.__new__(ForwardUsageStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> ForwardUsageStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.ForwardUsageStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.ForwardUsageStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__ForwardUsageStruct()

    @staticmethod
    def __get_metadata__():
        return ForwardUsageStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.ForwardUsageStruct"

    @_python__property
    def foo(self) -> _typing.Optional[ForwardUsageRoot]:
        if self._fbthrift_inner__foo is None:
            __python_val = self._fbthrift__inner.foo
            if __python_val is None:
                return None
            self._fbthrift_inner__foo = ForwardUsageRoot.from_python(__python_val)

        return self._fbthrift_inner__foo


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, ForwardUsageStruct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, ForwardUsageStruct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("ForwardUsageStruct")

class ForwardUsageByRef(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__foo",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.ForwardUsageByRef
    _FBTHRIFT__FIELD_NAMES = (
        "foo",
    )
    _fbthrift__inner : _fbthrift_python_types.ForwardUsageByRef
    _fbthrift_inner__foo : _typing.Optional[ForwardUsageRoot] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.ForwardUsageByRef(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.ForwardUsageByRef(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> ForwardUsageByRef:
        instance = super().__new__(cls)
        instance._fbthrift_inner__foo = None
        return instance

    def __call__(self, **kwargs) -> ForwardUsageByRef:
        return ForwardUsageByRef.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.ForwardUsageByRef) -> ForwardUsageByRef:
        inst = ForwardUsageByRef.__new__(ForwardUsageByRef)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> ForwardUsageByRef:
        return self

    def _to_python(self) -> _fbthrift_python_types.ForwardUsageByRef:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.ForwardUsageByRef, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__ForwardUsageByRef()

    @staticmethod
    def __get_metadata__():
        return ForwardUsageByRef._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.ForwardUsageByRef"

    @_python__property
    def foo(self) -> _typing.Optional[ForwardUsageRoot]:
        if self._fbthrift_inner__foo is None:
            __python_val = self._fbthrift__inner.foo
            if __python_val is None:
                return None
            self._fbthrift_inner__foo = ForwardUsageRoot.from_python(__python_val)

        return self._fbthrift_inner__foo


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, ForwardUsageByRef):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, ForwardUsageByRef):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("ForwardUsageByRef")

class IncompleteMap(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.IncompleteMap
    _FBTHRIFT__FIELD_NAMES = (
        "field",
    )
    _fbthrift__inner : _fbthrift_python_types.IncompleteMap
    _fbthrift_inner__field : _typing.Optional[_typing.Mapping[int, IncompleteMapDep]] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.IncompleteMap(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.IncompleteMap(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> IncompleteMap:
        instance = super().__new__(cls)
        instance._fbthrift_inner__field = None
        return instance

    def __call__(self, **kwargs) -> IncompleteMap:
        return IncompleteMap.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.IncompleteMap) -> IncompleteMap:
        inst = IncompleteMap.__new__(IncompleteMap)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> IncompleteMap:
        return self

    def _to_python(self) -> _fbthrift_python_types.IncompleteMap:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.IncompleteMap, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__IncompleteMap()

    @staticmethod
    def __get_metadata__():
        return IncompleteMap._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.IncompleteMap"

    @_python__property
    def field(self) -> _typing.Optional[_typing.Mapping[int, IncompleteMapDep]]:
        if self._fbthrift_inner__field is None:
            __python_val = self._fbthrift__inner.field
            if __python_val is None:
                return None
            self._fbthrift_inner__field = Map__i32_IncompleteMapDep.from_python(__python_val)

        return self._fbthrift_inner__field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, IncompleteMap):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, IncompleteMap):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("IncompleteMap")

class IncompleteMapDep(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.IncompleteMapDep
    _FBTHRIFT__FIELD_NAMES = (
    )
    _fbthrift__inner : _fbthrift_python_types.IncompleteMapDep


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.IncompleteMapDep(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.IncompleteMapDep(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> IncompleteMapDep:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> IncompleteMapDep:
        return IncompleteMapDep.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.IncompleteMapDep) -> IncompleteMapDep:
        inst = IncompleteMapDep.__new__(IncompleteMapDep)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> IncompleteMapDep:
        return self

    def _to_python(self) -> _fbthrift_python_types.IncompleteMapDep:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.IncompleteMapDep, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__IncompleteMapDep()

    @staticmethod
    def __get_metadata__():
        return IncompleteMapDep._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.IncompleteMapDep"


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 0

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, IncompleteMapDep):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, IncompleteMapDep):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("IncompleteMapDep")

class CompleteMap(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.CompleteMap
    _FBTHRIFT__FIELD_NAMES = (
        "field",
    )
    _fbthrift__inner : _fbthrift_python_types.CompleteMap
    _fbthrift_inner__field : _typing.Optional[_typing.Mapping[int, CompleteMapDep]] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.CompleteMap(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.CompleteMap(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> CompleteMap:
        instance = super().__new__(cls)
        instance._fbthrift_inner__field = None
        return instance

    def __call__(self, **kwargs) -> CompleteMap:
        return CompleteMap.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.CompleteMap) -> CompleteMap:
        inst = CompleteMap.__new__(CompleteMap)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> CompleteMap:
        return self

    def _to_python(self) -> _fbthrift_python_types.CompleteMap:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.CompleteMap, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__CompleteMap()

    @staticmethod
    def __get_metadata__():
        return CompleteMap._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.CompleteMap"

    @_python__property
    def field(self) -> _typing.Optional[_typing.Mapping[int, CompleteMapDep]]:
        if self._fbthrift_inner__field is None:
            __python_val = self._fbthrift__inner.field
            if __python_val is None:
                return None
            self._fbthrift_inner__field = std_unordered_map__Map__i32_CompleteMapDep.from_python(__python_val)

        return self._fbthrift_inner__field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, CompleteMap):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, CompleteMap):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("CompleteMap")

class CompleteMapDep(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.CompleteMapDep
    _FBTHRIFT__FIELD_NAMES = (
    )
    _fbthrift__inner : _fbthrift_python_types.CompleteMapDep


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.CompleteMapDep(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.CompleteMapDep(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> CompleteMapDep:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> CompleteMapDep:
        return CompleteMapDep.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.CompleteMapDep) -> CompleteMapDep:
        inst = CompleteMapDep.__new__(CompleteMapDep)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> CompleteMapDep:
        return self

    def _to_python(self) -> _fbthrift_python_types.CompleteMapDep:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.CompleteMapDep, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__CompleteMapDep()

    @staticmethod
    def __get_metadata__():
        return CompleteMapDep._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.CompleteMapDep"


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 0

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, CompleteMapDep):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, CompleteMapDep):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("CompleteMapDep")

class IncompleteList(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.IncompleteList
    _FBTHRIFT__FIELD_NAMES = (
        "field",
    )
    _fbthrift__inner : _fbthrift_python_types.IncompleteList
    _fbthrift_inner__field : _typing.Optional[_typing.Sequence[IncompleteListDep]] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.IncompleteList(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.IncompleteList(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> IncompleteList:
        instance = super().__new__(cls)
        instance._fbthrift_inner__field = None
        return instance

    def __call__(self, **kwargs) -> IncompleteList:
        return IncompleteList.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.IncompleteList) -> IncompleteList:
        inst = IncompleteList.__new__(IncompleteList)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> IncompleteList:
        return self

    def _to_python(self) -> _fbthrift_python_types.IncompleteList:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.IncompleteList, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__IncompleteList()

    @staticmethod
    def __get_metadata__():
        return IncompleteList._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.IncompleteList"

    @_python__property
    def field(self) -> _typing.Optional[_typing.Sequence[IncompleteListDep]]:
        if self._fbthrift_inner__field is None:
            __python_val = self._fbthrift__inner.field
            if __python_val is None:
                return None
            self._fbthrift_inner__field = _std_list__List__IncompleteListDep.from_python(__python_val)

        return self._fbthrift_inner__field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, IncompleteList):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, IncompleteList):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("IncompleteList")

class IncompleteListDep(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.IncompleteListDep
    _FBTHRIFT__FIELD_NAMES = (
    )
    _fbthrift__inner : _fbthrift_python_types.IncompleteListDep


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.IncompleteListDep(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.IncompleteListDep(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> IncompleteListDep:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> IncompleteListDep:
        return IncompleteListDep.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.IncompleteListDep) -> IncompleteListDep:
        inst = IncompleteListDep.__new__(IncompleteListDep)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> IncompleteListDep:
        return self

    def _to_python(self) -> _fbthrift_python_types.IncompleteListDep:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.IncompleteListDep, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__IncompleteListDep()

    @staticmethod
    def __get_metadata__():
        return IncompleteListDep._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.IncompleteListDep"


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 0

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, IncompleteListDep):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, IncompleteListDep):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("IncompleteListDep")

class CompleteList(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.CompleteList
    _FBTHRIFT__FIELD_NAMES = (
        "field",
    )
    _fbthrift__inner : _fbthrift_python_types.CompleteList
    _fbthrift_inner__field : _typing.Optional[_typing.Sequence[CompleteListDep]] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.CompleteList(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.CompleteList(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> CompleteList:
        instance = super().__new__(cls)
        instance._fbthrift_inner__field = None
        return instance

    def __call__(self, **kwargs) -> CompleteList:
        return CompleteList.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.CompleteList) -> CompleteList:
        inst = CompleteList.__new__(CompleteList)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> CompleteList:
        return self

    def _to_python(self) -> _fbthrift_python_types.CompleteList:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.CompleteList, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__CompleteList()

    @staticmethod
    def __get_metadata__():
        return CompleteList._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.CompleteList"

    @_python__property
    def field(self) -> _typing.Optional[_typing.Sequence[CompleteListDep]]:
        if self._fbthrift_inner__field is None:
            __python_val = self._fbthrift__inner.field
            if __python_val is None:
                return None
            self._fbthrift_inner__field = folly_small_vector__List__CompleteListDep.from_python(__python_val)

        return self._fbthrift_inner__field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, CompleteList):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, CompleteList):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("CompleteList")

class CompleteListDep(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.CompleteListDep
    _FBTHRIFT__FIELD_NAMES = (
    )
    _fbthrift__inner : _fbthrift_python_types.CompleteListDep


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.CompleteListDep(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.CompleteListDep(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> CompleteListDep:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> CompleteListDep:
        return CompleteListDep.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.CompleteListDep) -> CompleteListDep:
        inst = CompleteListDep.__new__(CompleteListDep)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> CompleteListDep:
        return self

    def _to_python(self) -> _fbthrift_python_types.CompleteListDep:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.CompleteListDep, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__CompleteListDep()

    @staticmethod
    def __get_metadata__():
        return CompleteListDep._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.CompleteListDep"


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 0

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, CompleteListDep):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, CompleteListDep):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("CompleteListDep")

class AdaptedList(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.AdaptedList
    _FBTHRIFT__FIELD_NAMES = (
        "field",
    )
    _fbthrift__inner : _fbthrift_python_types.AdaptedList
    _fbthrift_inner__field : _typing.Optional[_typing.Sequence[AdaptedListDep]] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.AdaptedList(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.AdaptedList(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> AdaptedList:
        instance = super().__new__(cls)
        instance._fbthrift_inner__field = None
        return instance

    def __call__(self, **kwargs) -> AdaptedList:
        return AdaptedList.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.AdaptedList) -> AdaptedList:
        inst = AdaptedList.__new__(AdaptedList)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> AdaptedList:
        return self

    def _to_python(self) -> _fbthrift_python_types.AdaptedList:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.AdaptedList, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__AdaptedList()

    @staticmethod
    def __get_metadata__():
        return AdaptedList._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.AdaptedList"

    @_python__property
    def field(self) -> _typing.Optional[_typing.Sequence[AdaptedListDep]]:
        if self._fbthrift_inner__field is None:
            __python_val = self._fbthrift__inner.field
            if __python_val is None:
                return None
            self._fbthrift_inner__field = List__AdaptedListDep.from_python(__python_val)

        return self._fbthrift_inner__field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, AdaptedList):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, AdaptedList):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("AdaptedList")

class DependentAdaptedList(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.DependentAdaptedList
    _FBTHRIFT__FIELD_NAMES = (
        "field",
    )
    _fbthrift__inner : _fbthrift_python_types.DependentAdaptedList
    _fbthrift_inner__field : _typing.Optional[_typing.Sequence[DependentAdaptedListDep]] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.DependentAdaptedList(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.DependentAdaptedList(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> DependentAdaptedList:
        instance = super().__new__(cls)
        instance._fbthrift_inner__field = None
        return instance

    def __call__(self, **kwargs) -> DependentAdaptedList:
        return DependentAdaptedList.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.DependentAdaptedList) -> DependentAdaptedList:
        inst = DependentAdaptedList.__new__(DependentAdaptedList)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> DependentAdaptedList:
        return self

    def _to_python(self) -> _fbthrift_python_types.DependentAdaptedList:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.DependentAdaptedList, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__DependentAdaptedList()

    @staticmethod
    def __get_metadata__():
        return DependentAdaptedList._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.DependentAdaptedList"

    @_python__property
    def field(self) -> _typing.Optional[_typing.Sequence[DependentAdaptedListDep]]:
        if self._fbthrift_inner__field is None:
            __python_val = self._fbthrift__inner.field
            if __python_val is None:
                return None
            self._fbthrift_inner__field = List__DependentAdaptedListDep.from_python(__python_val)

        return self._fbthrift_inner__field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, DependentAdaptedList):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, DependentAdaptedList):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("DependentAdaptedList")

class AllocatorAware(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__aa_list",
        "_fbthrift_inner__aa_set",
        "_fbthrift_inner__aa_map",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.AllocatorAware
    _FBTHRIFT__FIELD_NAMES = (
        "aa_list",
        "aa_set",
        "aa_map",
        "aa_string",
        "not_a_container",
        "aa_unique",
        "aa_shared",
    )
    _fbthrift__inner : _fbthrift_python_types.AllocatorAware
    _fbthrift_inner__aa_list : _typing.Sequence[int] | None
    _fbthrift_inner__aa_set : _typing.AbstractSet[int] | None
    _fbthrift_inner__aa_map : _typing.Mapping[int, int] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.AllocatorAware(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.AllocatorAware(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> AllocatorAware:
        instance = super().__new__(cls)
        instance._fbthrift_inner__aa_list = None
        instance._fbthrift_inner__aa_set = None
        instance._fbthrift_inner__aa_map = None
        return instance

    def __call__(self, **kwargs) -> AllocatorAware:
        return AllocatorAware.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.AllocatorAware) -> AllocatorAware:
        inst = AllocatorAware.__new__(AllocatorAware)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> AllocatorAware:
        return self

    def _to_python(self) -> _fbthrift_python_types.AllocatorAware:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.AllocatorAware, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__AllocatorAware()

    @staticmethod
    def __get_metadata__():
        return AllocatorAware._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.AllocatorAware"

    @_python__property
    def aa_list(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__aa_list is None:
            __python_val = self._fbthrift__inner.aa_list
            self._fbthrift_inner__aa_list = List__i32.from_python(__python_val)

        return self._fbthrift_inner__aa_list

    @_python__property
    def aa_set(self) -> _typing.AbstractSet[int]:
        if self._fbthrift_inner__aa_set is None:
            __python_val = self._fbthrift__inner.aa_set
            self._fbthrift_inner__aa_set = Set__i32.from_python(__python_val)

        return self._fbthrift_inner__aa_set

    @_python__property
    def aa_map(self) -> _typing.Mapping[int, int]:
        if self._fbthrift_inner__aa_map is None:
            __python_val = self._fbthrift__inner.aa_map
            self._fbthrift_inner__aa_map = Map__i32_i32.from_python(__python_val)

        return self._fbthrift_inner__aa_map

    @_python__property
    def aa_string(self) -> str:
        return self._fbthrift__inner.aa_string

    @_python__property
    def not_a_container(self) -> int:
        return self._fbthrift__inner.not_a_container

    @_python__property
    def aa_unique(self) -> _typing.Optional[int]:
        return self._fbthrift__inner.aa_unique

    @_python__property
    def aa_shared(self) -> _typing.Optional[int]:
        return self._fbthrift__inner.aa_shared


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 7

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, AllocatorAware):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, AllocatorAware):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("AllocatorAware")

class AllocatorAware2(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.AllocatorAware2
    _FBTHRIFT__FIELD_NAMES = (
        "not_a_container",
        "box_field",
    )
    _fbthrift__inner : _fbthrift_python_types.AllocatorAware2


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.AllocatorAware2(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.AllocatorAware2(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> AllocatorAware2:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> AllocatorAware2:
        return AllocatorAware2.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.AllocatorAware2) -> AllocatorAware2:
        inst = AllocatorAware2.__new__(AllocatorAware2)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> AllocatorAware2:
        return self

    def _to_python(self) -> _fbthrift_python_types.AllocatorAware2:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.AllocatorAware2, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__AllocatorAware2()

    @staticmethod
    def __get_metadata__():
        return AllocatorAware2._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.AllocatorAware2"

    @_python__property
    def not_a_container(self) -> int:
        return self._fbthrift__inner.not_a_container

    @_python__property
    def box_field(self) -> _typing.Optional[int]:
        return self._fbthrift__inner.box_field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, AllocatorAware2):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, AllocatorAware2):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("AllocatorAware2")

class TypedefStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.TypedefStruct
    _FBTHRIFT__FIELD_NAMES = (
        "i32_field",
        "IntTypedef_field",
        "UintTypedef_field",
    )
    _fbthrift__inner : _fbthrift_python_types.TypedefStruct


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.TypedefStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.TypedefStruct(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> TypedefStruct:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> TypedefStruct:
        return TypedefStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.TypedefStruct) -> TypedefStruct:
        inst = TypedefStruct.__new__(TypedefStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> TypedefStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.TypedefStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.TypedefStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__TypedefStruct()

    @staticmethod
    def __get_metadata__():
        return TypedefStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.TypedefStruct"

    @_python__property
    def i32_field(self) -> int:
        return self._fbthrift__inner.i32_field

    @_python__property
    def IntTypedef_field(self) -> int:
        return self._fbthrift__inner.IntTypedef_field

    @_python__property
    def UintTypedef_field(self) -> int:
        return self._fbthrift__inner.UintTypedef_field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 3

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, TypedefStruct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, TypedefStruct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("TypedefStruct")

class StructWithDoubleUnderscores(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.StructWithDoubleUnderscores
    _FBTHRIFT__FIELD_NAMES = (
        "__field",
    )
    _fbthrift__inner : _fbthrift_python_types.StructWithDoubleUnderscores


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.StructWithDoubleUnderscores(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.StructWithDoubleUnderscores(*args, **kwargs)


    def __new__(cls, *args, **kwargs) -> StructWithDoubleUnderscores:
        instance = super().__new__(cls)
        return instance

    def __call__(self, **kwargs) -> StructWithDoubleUnderscores:
        return StructWithDoubleUnderscores.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.StructWithDoubleUnderscores) -> StructWithDoubleUnderscores:
        inst = StructWithDoubleUnderscores.__new__(StructWithDoubleUnderscores)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> StructWithDoubleUnderscores:
        return self

    def _to_python(self) -> _fbthrift_python_types.StructWithDoubleUnderscores:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithDoubleUnderscores, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__StructWithDoubleUnderscores()

    @staticmethod
    def __get_metadata__():
        return StructWithDoubleUnderscores._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithDoubleUnderscores"

    @_python__property
    def __field(self) -> int:
        return self._fbthrift__inner.__field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, StructWithDoubleUnderscores):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, StructWithDoubleUnderscores):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("StructWithDoubleUnderscores")


### Constants
